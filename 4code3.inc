[ ] //*****************************************************************************
[ ] 
[ ] // 4CODE3.INC
[ ] // 44 functions
[ ] 
[ ] // Standard 4TEST Extentions
[ ] // Extentions to the 4Test language applicable to most applications.
[ ] // REQUIRES QA PARTNER v2.0+
[ ] 
[ ] // Original Author: Mark Hemsley
[ ] // Initial Date:  4/2/94
[ ] 
[ ] // Copyright (c) 1993, 1994, 1995, 1998 Peak Enterprises.
[ ] // All Rights Reserved, Distributed as FreeWare
[ ] // This file must be distributed in it's entierty, including this notice
[ ] // No rights are granted for altering and then redistributing this code
[ ] // (but if you have suggestions, I'll be happy to consider them for the
[ ] // next release). This code is unsupported, but bug reports are welcome.
[ ] 
[ ] //*****************************************************************************
[ ] 
[ ] use "bwcompat.inc"
[ ] 
[ ] // Extentions related
[ ] const P4TEX_VERSION = 3.0 // for compatability
[ ] const PEAK_4TEST_EXTENTION_VERSION = 3.0
[ ] const PEAK_4TEST_EXTENTION_REVISION = 0.19981101
[ ] 
[ ] const CRLF = chr (13) + chr (10)
[ ] const crlf = CRLF
[ ] const CR = chr (13)
[ ] const cr = CR
[ ] 
[ ] type TEXT is STRING, LIST OF STRING
[ ] 
[ ] type ERRORDATA is STRING, LIST
[ ] type CONTAINS is STRING, LIST OF ANYTYPE, RECT, WNDTAG
[ ] 
[+] type WNDSTATUS is enum
	[ ] ACTIVE    // WINDOW IS ACTIVE
	[ ] NOTACTIVE   // WINDOW IS NOT ACTIVE, BUT ALSO NOT OBSCURED (OUT OF FOCUS)
	[ ]     // NOTACTIVE IS NOT SUPPORTED YET!!
	[ ] OBSCURED   // WINDOW IS OBSCURED BY ANOTHER WINDOW
	[ ] DISABLED   // WINDOW IS DISABLED
	[ ] MISSING   // WINDOW DOES NOT EXIST
	[ ] 
[ ] type DISMISSIT is WNDTAG, WINDOW
[+] type DISMISSTYPE is enum
	[ ] ACCEPT
	[ ] CANCEL
	[ ] CUSTOM
	[ ] 
	[ ] // Exceptions that can be generated by this code.
[ ] const P4TEX_CANT_CHANGE_STATIC_READ_ONLY = -20000
[ ] 
[ ] // ***************************************************************************
[ ] // LastMemeber
[ ] // Returns the Last member of a list
[ ] // ***************************************************************************
[+] ANYTYPE LastMemeber(LIST OF ANYTYPE laIncoming)
	[ ] anytype result = {}
	[-] if laIncoming != {}
		[ ] integer pos = ListCount(laIncoming)
		[ ] result = laIncoming[pos]
	[ ] return result
[ ] 
[ ] // ***************************************************************************
[ ] // CallStack
[ ] // Returns the callstack at time of entry
[ ] // ***************************************************************************
[+] ANYTYPE CallStack()
	[-] do
		[ ] raise 1
	[-] except
		[ ] return ExceptCalls()
[ ] 
[ ] // ***************************************************************************
[ ] // LastPos
[ ] // Returns the position where the last occurrence of a given substring appears
[ ] // ***************************************************************************
[+] INTEGER LastPos(STRING sIncoming, STRING sFindMe)
	[ ] INTEGER iResult = 0
	[ ] INTEGER iTemp = 0
	[ ] STRING sTemp = sIncoming
	[ ] BOOLEAN bGoFlag = TRUE
	[-] while bGoFlag
		[ ] iTemp = StrPos(sFindMe, sTemp)
		[ ] iResult = iResult + iTemp
		[ ] sTemp = right(sTemp, Len(sTemp)-iTemp)
		[-] if iTemp == 0
			[ ] bGoFlag = FALSE
	[ ] return iResult
[ ] 
[ ] // ***************************************************************************
[ ] // Between
[ ] // Returns everything between two other characters. If the characters 
[ ] // occour more than once, the routine takes the first instances it encounters.
[ ] // ***************************************************************************
[ ] 
[-] STRING Between(STRING sIncoming, STRING sLeft, STRING sRight)
	[ ] STRING Result = sIncoming
	[ ] Result = LeftOf(Result, sRight)
	[ ] Result = RightOf(Result, sLeft)
	[ ] return Result
[ ] 
[ ] // ***************************************************************************
[ ] // LeftOf
[ ] // Returns everything to the left of the last occourance of a substring
[ ] // ***************************************************************************
[+] STRING LeftOf(STRING sIncoming, STRING sFindMe)
	[ ] return Left(sIncoming, LastPos(sIncoming, sFindMe)-1)
[ ] 
[ ] // ***************************************************************************
[ ] // RightOf
[ ] // Returns everything to the right of the last occourance of a substring
[ ] // ***************************************************************************
[+] STRING RightOf(STRING sIncoming, STRING sFindMe)
	[ ] //return SubStr(sIncoming, LastPos(sIncoming, sFindMe)+1, Len(sIncoming))
	[ ] return SubStr(sIncoming, LastPos(sIncoming, sFindMe)+Len(sFindMe))
[ ] 
[ ] // ***************************************************************************
[ ] // LastChar
[ ] // Returns string of last character of a string or "" if string is empty or NULL
[ ] // ***************************************************************************
[+] STRING LastChar (STRING sIncoming NULL optional)
	[-] if sIncoming == NULL
		[ ] sIncoming = ""
	[-] if Len (sIncoming) > 0
		[ ] sIncoming = sIncoming[Len (sIncoming)]
	[ ] return sIncoming
[ ] 
[ ] // ***************************************************************************
[ ] // StripLast
[ ] // Returns string of incoming minus the last character
[ ] // ***************************************************************************
[+] STRING StripLast(STRING sIncoming NULL optional)
	[-] if sIncoming == NULL
		[ ] sIncoming = ""
	[-] if Len (sIncoming) > 0
		[ ] sIncoming = Left(sIncoming,Len(sIncoming) - 1)
	[ ] return sIncoming
	[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // SelectFieldFromCSVList
[ ] // Returns list of string of specified field number from a csv list
[ ] // ***************************************************************************
[+] LIST OF STRING SelectFieldFromCSVList (LIST OF STRING csvData, INTEGER iFieldNum)
	[ ] LIST OF STRING lsResult
	[ ] ANYTYPE item
	[-] for each item in csvData
		[ ] ListAppend (lsResult, ConvertCSVToList (item)[iFieldNum])
		[ ] 
	[ ] return lsResult
[ ] 
[ ] // ***************************************************************************
[ ] // ListAdd
[ ] // no return value
[ ] 
[ ] // Appends second list specified to end of first list specified
[ ] 
[ ] // ***************************************************************************
[+] ListAdd (inout LIST OF ANYTYPE laListToAppendTo, ANYTYPE laListToAppendFrom)
	[-] if ! IsList (laListToAppendFrom)
		[-] laListToAppendFrom = {...}
			[ ] laListToAppendFrom
		[ ] 
	[ ] ANYTYPE item
	[-] for each item in laListToAppendFrom
		[ ] ListAppend (laListToAppendTo, item)
[ ] 
[ ] // ***************************************************************************
[ ] // ConvertCSVtoList
[ ] // Returns list of string of CSV data.
[ ] // ***************************************************************************
[+] LIST OF STRING ConvertCSVtoList (STRING csvData)
	[ ] return Parse (csvData, ",")
[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // Parse
[ ] // Returns list of string from string and delimiter
[ ] // ***************************************************************************
[+] LIST OF STRING Parse (STRING sIncoming, STRING sDelimiter)
	[ ] LIST OF STRING lsResult = {}
	[ ] INTEGER iPosition = 0
	[ ] STRING sCurrent
	[ ] sIncoming = sIncoming + sDelimiter + ' '
	[ ] 
	[-] while len (trim (sIncoming)) > 0 && Assign (iPosition, StrPos (sDelimiter, sIncoming)) > 0
		[ ] ListAppend (lsResult, SubStr (sIncoming, 1, iPosition - 1))
		[ ] sIncoming = SubStr (sIncoming, iPosition + len (sDelimiter), 1000000)
		[ ] 
	[ ] return lsResult
[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // Assign
[ ] // Returns anytype of aValue, and assigns aVar the same value.
[ ] 
[ ] // Used in a situation where you want to assign a value to a variable and
[ ] // also test the value (you can do this in C, but not in 4Test).
[ ] 
[ ] // ***************************************************************************
[+] ANYTYPE Assign (inout ANYTYPE aVar, ANYTYPE aValue NULL)
	[ ] aVar = aValue
	[ ] return aValue
[ ] 
[ ] // ***************************************************************************
[ ] // Contains
[ ] // Returns bool true if arg1 (super) contains arg2 (sub)
[ ] // used in a wide variety of places. Accepts string, list wndtag & rect args.
[ ] // NOTE: When using WndTag args (and variables MUST be declared as WndTag)
[ ] // a RECT operation is performed on the absolute rects of the passed wndtags.
[ ] // Since wndtag is a different type of string, if either of the passed wndtags
[ ] // does not exist, then the compare happens on the string.
[ ] // WARNING!!! WHEN USING WITH RECT ARGUMENTS MAKE !!SURE!! THAT BOTH RECTs
[ ] // ARE RELITIVE TO THE SAME ORIGIN!!! OTHERWISE RESULT IS MEANINGLESS!!
[ ] // ***************************************************************************
[+] BOOLEAN Contains (CONTAINS superitem, CONTAINS subitem, DATATYPE comptype optional)
	[ ] ANYTYPE supertype = TypeOf (superitem)
	[ ] ANYTYPE subtype = TypeOf (subitem)
	[ ] BOOLEAN result = FALSE
	[ ] 
	[-] if comptype == NULL
		[-] if (supertype == RECT && subtype == RECT) || (supertype == LIST) || (supertype == STRING && subtype == STRING) // if a pair of RECTs OR
			[ ] // super is a list    OR
			[ ] // their both strings
			[ ] // check it. ELSE result is
			[-] switch supertype // false as set above.
				[-] case RECT // do RECT -- math it out.
					[ ] result = rContains (superitem, subitem)
				[-] case STRING
					[-] if left(superitem,2) == '/['
						[-] if WND_Exists (superitem, 0) && WND_Exists (subitem, 0)
							[ ] // if both strings exist as windows
							[ ] RECT superrect = WND_GetRect (superitem, TRUE)
							[ ] RECT subrect = WND_GetRect (subitem, TRUE)
							[ ] result = Contains (superrect, subrect)
							[ ] // nope, do straight string search
					[-] else
						[ ] result = sContains (superitem, subitem)
				[-] case LIST
					[ ] result = lContains (superitem, subitem)
	[-] else
		[-] switch comptype
			[-] case RECT
				[ ] result = rContains (superitem, subitem)
			[-] case STRING
				[ ] result = sContains (superitem, subitem)
			[-] case LIST
				[ ] result = lContains (superitem, subitem)
				[ ] 
	[ ] return result
[ ] 
[ ] // ***************************************************************************
[ ] // lContains
[ ] // Returns bool true if arg1 (super) contains arg2 (sub) FOR list ONLY
[ ] // ***************************************************************************
[+] BOOLEAN lContains (LIST OF ANYTYPE superitem, ANYTYPE subitem)
	[ ] BOOLEAN result = FALSE
	[ ] ANYTYPE supertype = TypeOf (superitem)
	[ ] ANYTYPE subtype = TypeOf (subitem)
	[ ] 
	[ ] ANYTYPE item     // used in FOR EACH loop
	[-] for each item in superitem  // now check em all
		[-] do         // cancels type mismatch errors
			[-] if subtype == STRING   // if a pair of strings...
				[-] if scontains (item, subitem)
					[ ] result = TRUE    // recursive check says true!
					[ ]       // if NOT string
			[-] else
				[-] if item == subitem     // Well, checkem out
					[ ] result = TRUE
		[ ] except         // DO NOTHING. GRABS TYPE MISMATCH ERRORS
		[ ] 
	[ ] return result
[ ] 
[ ] // ***************************************************************************
[ ] // rContains
[ ] // Returns bool true if arg1 (super) contains arg2 (sub) FOR RECT ONLY
[ ] // ***************************************************************************
[+] BOOLEAN rContains (RECT superitem, RECT subitem)
	[ ] BOOLEAN result = FALSE
	[ ] 
	[-] if subitem.xPos >= superitem.xPos && subitem.yPos >= superitem.yPos && (subitem.xPos + subitem.xSize) <= (superitem.xPos + superitem.xSize) && (subitem.yPos + subitem.ySize) <= (superitem.yPos + superitem.ySize) // is sub's xy greater?
		[ ] // how about terminus nodes?
		[ ] result = TRUE // then sub is within super!
		[ ] 
	[ ] return result
[ ] 
[ ] // ***************************************************************************
[ ] // sContains
[ ] // Returns bool true if arg1 (super) contains arg2 (sub) FOR string ONLY
[ ] // ***************************************************************************
[+] BOOLEAN sContains (STRING superitem, STRING subitem)
	[ ] BOOLEAN result = FALSE
	[ ] 
	[-] if strpos (subitem, superitem) > 0
		[ ] result = TRUE
		[ ] 
	[ ] return result
[ ] 
[ ] // ***************************************************************************
[ ] // Digits
[ ] // Returns only numeric portions of a string as a number. For instance,
[ ] // "You Have $32,767.01 Dollars" returns 32767.01 But you have to take care,
[ ] // "32-27-53" returns 322753, "-32,545" returns -32545 and "510.649.0247"
[ ] // returns 510.6490247
[ ] // ***************************************************************************
[+] NUMBER Digits (STRING incoming)
	[ ] STRING numbers = "0123456789."
	[ ] INTEGER counter = 0
	[ ] STRING inprog = ""
	[ ] 
	[-] for counter = 1 to len (incoming)
		[-] if sContains (numbers, incoming[counter])
			[ ] inprog = "{inprog}{incoming[counter]}"
		[-] else if (counter == 1 && incoming[counter] == "-")
			[ ] inprog = "-"
			[ ] 
	[ ] return val (inprog)
[ ] 
[ ] // ***************************************************************************
[ ] // Iff
[ ] // Returns arg2 if arg1 evaluates to true, else arg3.
[ ] // (4Test didn't always have the C style conditional operator)
[ ] // ***************************************************************************
[+] ANYTYPE iff (BOOLEAN expression, ANYTYPE rtrue NULL, ANYTYPE rfalse NULL)
	[ ] ANYTYPE result = rfalse // set return value to rfalse
	[-] if (expression) // then eval expression
		[ ] result = rtrue // if true, alter return value to rtrue
		[ ] // if it was false, it just stays that way
	[ ] return result // now hand it back
[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // Istype
[ ] // Returns true if specified variable is initialized as type specified
[ ] //    IsBool(myvar)
[ ] //   IsDataclass(myvar)
[ ] //   IsInteger(myvar)
[ ] //    IsString(myvar)
[ ] //   IsWindow(myvar)
[ ] // ***************************************************************************
[+] private BOOLEAN IsType (ANYTYPE testvar NULL, DATATYPE maybetype)
	[ ] BOOLEAN retvalue = TRUE
	[ ] 
	[-] if testvar == NULL
		[ ] retvalue = FALSE
	[-] else
		[ ] retvalue = iff (typeof (testvar) == maybetype, TRUE, FALSE)
		[ ] 
	[ ] return retvalue
	[ ] 
[+] BOOLEAN IsBool (ANYTYPE testvar NULL)
	[ ] return IsType (testvar, BOOLEAN)
[+] BOOLEAN IsDataclass (ANYTYPE testvar NULL)
	[ ] return IsType (testvar, DATACLASS)
[+] BOOLEAN IsInteger (ANYTYPE testvar NULL)
	[ ] return IsType (testvar, INTEGER)
[+] BOOLEAN IsString (ANYTYPE testvar NULL)
	[ ] return IsType (testvar, STRING)
[+] BOOLEAN IsWindow (ANYTYPE testvar NULL)
	[ ] return IsType (testvar, WINDOW)
[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // IsEmpty
[ ] // Returns true if specified string == ""
[ ] // ***************************************************************************
[+] BOOLEAN IsEmpty (STRING sPassed)
	[ ] return iff (sPassed == "", TRUE, FALSE)
[ ] 
[ ] // ***************************************************************************
[ ] // WND_Status
[ ] // Returns enum of { ACTIVE, OBSCURED, DISABLED, MISSING } for a quick and
[ ] // consistant check of the status of a window. If window does not exist when
[ ] // WND_Status is called, the WND_Exists function will wait the number of
[ ] // seconds specified in the optional argument timeout.
[ ] // ***************************************************************************
[+] WNDSTATUS WND_Status (WNDTAG targetwindow, NUMBER timeout optional)
	[ ] WNDSTATUS windowstate = MISSING // Default. If not exists...
	[ ] 
	[-] if timeout == NULL
		[ ] timeout = 0.0 // were we handed a timeout? Nope, ok use 0
		[ ] 
	[ ] ANYTYPE PreviousTimeout = GUI_SetWindowTimeout (timeout)
	[ ] 
	[-] if WND_Exists (targetwindow) // if not exist, use default.
		[ ] // but if so...
		[ ] windowstate = ACTIVE // maybe active.
		[ ] 
		[-] do
			[ ] WND_VerifyActive (targetwindow) // this'll give us an exception
		[-] except // if it ain't active
			[-] switch ExceptNum () // now to find out which one
				[-] case E_GUITD_WINDOW_NOT_ENABLED
					[ ] windowstate = DISABLED
				[-] case E_GUITD_WINDOW_NOT_ACTIVE
					[ ] windowstate = OBSCURED
				[-] case E_GUITD_WINDOW_NOT_UNIQUE
					[ ] reraise
				[-] default
					[ ] print ("******************************")
					[ ] print ("* WND_STATUS({targetwindow})")
					[ ] print ("* INDECIPHERABLE CONDITION ON")
					[ ] print ("* WND_VERFIYACTIVE()")
					[ ] print ("******************************")
					[ ] listprint (exceptcalls ())
					[ ] print (exceptdata ())
					[ ] print ("ExceptNum() = {ExceptNum()}")
					[ ] reraise // something wierd happened
					[ ] 
	[ ] GUI_SetWindowTimeout (PreviousTimeout) // return timeout to original
	[ ] return windowstate // Have fun.
[ ] 
[ ] // ***************************************************************************
[ ] // WND_GetAppMainWindowTag
[ ] // Returns window tag of application level parent to the specified window
[ ] // if it exists. If not, raises E_GUITD_WINDOW_NOT_FOUND.
[ ] // ***************************************************************************
[+] WNDTAG WND_GetAppMainWindowTag (WNDTAG childtogetfrom)
	[-] if WND_Status (childtogetfrom) == MISSING
		[ ] raise E_GUITD_WINDOW_NOT_FOUND
	[-] else
		[ ] return APP_GetWindow (WND_GetAppID (childtogetfrom))
[ ] 
[ ] // ***************************************************************************
[ ] // WND_IsAllOnScreen
[ ] // Returns TRUE if specified window is all on the screen - that is if
[ ] // "/" Contains() checkme.
[ ] // NOTE: RETURNS FALSE IF WINDOW DOES NOT EXIST! - DOES NOT EXCEPT OUT!
[ ] // ***************************************************************************
[+] BOOLEAN WND_IsAllOnScreen (WNDTAG checkme)
	[ ] return iff (WND_Exists (checkme, 0), Contains ("/", checkme), FALSE)
[ ] 
[ ] // ***************************************************************************
[ ] // TAG_IsMenu
[ ] // Returns true if specified window tag contains $Menu
[ ] // ***************************************************************************
[+] BOOLEAN TAG_IsMenu (WNDTAG thistag)
	[ ] return sContains (thistag, '$Menu')
[ ] 
[ ] // ***************************************************************************
[ ] // TAG_StripAll
[ ] // Strip all but lowermost portions of windowtag exceluding class
[ ] // ***************************************************************************
[+] STRING TAG_StripAll (STRING windowtostrip)
	[-] while scontains (windowtostrip, "/")
		[ ] windowtostrip = substr (windowtostrip, strpos ("/", windowtostrip) + 1)
	[-] while scontains (windowtostrip, "]")
		[ ] windowtostrip = substr (windowtostrip, strpos ("]", windowtostrip) + 1)
	[ ] return windowtostrip
[ ] 
[ ] // ***************************************************************************
[ ] // TAG_StripParentage
[ ] // Strip all but lowermost portions of windowtag
[ ] // ***************************************************************************
[+] WNDTAG TAG_StripParentage (WNDTAG windowtostrip)
	[-] while contains (windowtostrip, "/")
		[ ] windowtostrip = SubStr (windowtostrip, StrPos ("/", windowtostrip) + 1)
	[ ] return windowtostrip
[ ] 
[ ] // ***************************************************************************
[ ] // DLG_Dismiss
[ ] // closes current or specified dialog box
[ ] // ***************************************************************************
[+] void DLG_Dismiss (DISMISSIT dlgtogetridof optional, DISMISSTYPE howto optional)
	[ ] STRING killme_wndtag // will hold the wndtag - once we have it
	[ ] STRING killme_class // class of specifed wndtag
	[ ] ANYTYPE killme_window // will hold the window - if applicable
	[ ] WNDTAG killme_override // overriding control name
	[ ] WNDSTATUS killme_status // what was our state at startup?
	[ ] ANYTYPE controllist // valid dismiss control operators
	[ ] ANYTYPE currentcontrol // used to process controllist
	[ ] 
	[ ] // ----------PRE INITIALIZATION----------
	[-] if IsWindow (dlgtogetridof) // were we handed a window?
		[ ] // initialize from that
		[ ] killme_wndtag = dlgtogetridof.WndTag // stash tag
		[ ] killme_window = dlgtogetridof // stash window
		[ ] // try to init from tag
	[-] else
		[-] if dlgtogetridof == NULL
			[ ] dlgtogetridof = WND_GetActive ()
		[ ] killme_wndtag = dlgtogetridof // store tag
		[ ] killme_window = FindWindow (dlgtogetridof) // & window
		[-] if killme_window != {} // findwindow returns a list
			[ ] killme_window = killme_window[1] // gimme the first one
			[ ] // tag & window (if exists) are now inited
			[ ] 
	[ ] killme_status = WND_Status (killme_wndtag) // go on ONLY if the window is avaliable
	[ ] killme_class = WND_GetClass (killme_wndtag) // dont forget it's type - we only do dialogs!
	[-] if (killme_status == ACTIVE || killme_status == OBSCURED) && killme_class == "DialogBox"
		[ ] // ----------FINISH INIT----------
		[-] if howto == NULL // has hiwto been initialized?
			[ ] howto = CANCEL // default operation
			[ ] 
		[ ] ANYTYPE howto_type = typeof (howto) // stash type
		[-] controllist = {...}
			[ ] "OK"
			[ ] "Yes"
			[ ] "Done"
			[ ] "Close"
			[ ] "Exit" // accept version
		[-] if howto_type != STRING && howto == CANCEL // is it cancel?
			[-] controllist = {...}
				[ ] "Cancel"
				[ ] "No"
				[ ] "Abort"
				[ ] "Close"
				[ ] "OK"
				[ ] "Exit"
				[ ] "Yes"
				[ ] "Done"
			[ ] 
		[-] if howto_type == STRING // if it's string, add it to list
			[ ] listinsert (controllist, 1, howto)
			[ ] howto = CUSTOM
			[ ] 
			[ ] // ----------TRY DISMISSING----------
		[-] if killme_status == OBSCURED // bring it to front
			[ ] WND_SetActive (killme_wndtag)
			[ ] 
		[-] if IsWindow (killme_window) // do we have a window object?
			[-] do
				[ ] killme_window.dismiss (iff (howto == CUSTOM, controllist[1], howto))
			[ ] except // maybe it didn't have one!
			[ ] 
		[-] if WND_Exists (killme_wndtag, 0) // does it still exist?
			[ ] // if so, window.dismiss() didn't
			[-] for each currentcontrol in controllist // ok, try all known controls
				[-] if WND_Exists (killme_wndtag, 0) && WND_Exists (currentcontrol, 0)
					[ ] pb_click (currentcontrol)
	[-] if WND_Exists (killme_wndtag, 0) // if still there, try smashing it.
		[ ] WND_Close (killme_wndtag)
[ ] 
[ ] // ***************************************************************************
[ ] // ***************************************************************************
[ ] // STATIC System
[ ] //   consts  P4TEX_CANT_CHANGE_STATIC_READ_ONLY
[ ] //  types  STATICS (record of lists)
[ ] //   private  STATICS slist
[ ] 
[ ] //  functions STATIC_Set(owner,key,value,readonly optional)
[ ] //      if item is read only, raise P4TEX_CANT_CHANGE_STATIC_READ_ONLY
[ ] //     STATIC_Get(owner,key)
[ ] //     STATIC_Drop(owner,key)
[ ] //      if item is read only, raise P4TEX_CANT_CHANGE_STATIC_READ_ONLY
[ ] //     STATIC_ChangeReadOnlyAttribute(owner, key)
[ ] //     STATIC_ReturnPoolForDebug()
[ ] // ***************************************************************************
[+] type  STATICS is record
	[ ] LIST OF STRING keys
	[ ] LIST OF ANYTYPE values
	[ ] LIST OF BOOLEAN attribs
[+] private STATICS slist = {...}
	[ ] {}
	[ ] {}
	[ ] {}
[ ] 
[+] void  STATIC_Set (STRING owner, STRING key, ANYTYPE value NULL, BOOLEAN readonly optional)
	[-] if readonly == NULL // if not specified, default is false
		[ ] readonly = FALSE
		[ ] 
	[ ] INTEGER found = listfind (slist.keys, "{owner}|{key}") // try & find it
	[-] if found == 0 // if it hasn't already been set,
		[ ] listappend (slist.keys, "{owner}|{key}") // append it to the end
		[ ] listappend (slist.values, value)
		[ ] listappend (slist.attribs, readonly)
		[ ] // otherwise
	[-] else
		[-] if slist.attribs[found] == TRUE // if read only, bitch
			[ ] raise P4TEX_CANT_CHANGE_STATIC_READ_ONLY, "ERROR in STATIC_SET, attempt to change a value on a read only item"
			[ ] // if not,
		[-] else
			[ ] slist.attribs[found] = readonly // set the new values.
			[ ] slist.values[found] = value
			[ ] 
[+] ANYTYPE STATIC_Get (STRING owner, STRING key)
	[ ] ANYTYPE result = NULL // will return as null if no find
	[ ] INTEGER found = listfind (slist.keys, "{owner}|{key}") // try & find it
	[ ] 
	[-] if found != 0 // if it exists,
		[ ] result = slist.values[found]
		[ ] 
	[ ] return result
	[ ] 
[+] void  STATIC_Drop (STRING owner, STRING key)
	[ ] INTEGER found = listfind (slist.keys, "{owner}|{key}") // try & find it
	[-] if found != 0 // if it exists,
		[-] if slist.attribs[found] == TRUE // if read only, bitch
			[ ] raise P4TEX_CANT_CHANGE_STATIC_READ_ONLY, "ERROR in STATIC_SET, attempt to change a value on a read only item"
			[ ] // if not,
		[-] else
			[ ] listdelete (slist.keys, found) // delet 'em!
			[ ] listdelete (slist.values, found)
			[ ] listdelete (slist.attribs, found)
			[ ] 
[+] ANYTYPE STATIC_ChangeReadOnlyAttribute (STRING owner, STRING key)
	[ ] INTEGER found = listfind (slist.keys, "{owner}|{key}") // try & find it
	[-] if found != 0 // if it exists,
		[ ] slist.attribs[found] = FALSE
		[ ] 
[+] ANYTYPE STATIC_ReturnPoolForDebug ()
	[ ] return slist
[ ] 
[ ] // ***************************************************************************
[ ] // ***************************************************************************
[ ] // Error Logging System - Used to record information about test failures in a
[ ] // standard way.
[ ] //  functions Init()
[ ] //      used to store data about save format (in 4code versions
[ ] //      before 3.0 this does nothing)
[ ] //     LogApplicationError(errordata)
[ ] //     LogAutomationError(errordata)
[ ] //     LogComment(errordata)
[ ] //     LogSleuth(errordata)
[ ] //     LogTrace(errordata)
[ ] //      saves data of specified type and continue test.
[ ] 
[ ] // ***************************************************************************
[ ] 
[ ] //type ERRORDATA is string, list;
[ ] 
[ ] Init ()
[ ] 
[+] LogApplicationError (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "Application ERROR :")
	[ ] 
[+] LogAutomationError (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "Automation ERROR  :")
	[ ] 
[+] LogComment (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "Comment           :")
	[ ] 
[+] LogSleuth (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "SLEUTH----------- :")
	[ ] 
[+] LogTrace (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "TRACE------------ :")
	[ ] 
[+] private WriteError (ERRORDATA errormsg, STRING msgprefix)
	[-] if IsList (errormsg)
		[ ] ANYTYPE item
		[-] for each item in errormsg
			[ ] LogError ("{msgprefix}, {item}")
	[-] else
		[ ] LogError ("{msgprefix} {errormsg}")
		[ ] 
[ ] 
[ ] // ***************************************************************************
[ ] // ***************************************************************************
[ ] // The following function is writen by Diana Wan
[ ] // ***************************************************************************
[ ] 
[+] string BtnParm(string sIncome)
	[-] if !sContains(sIncome,"(") || !sContains(sIncome, ")")
		[ ] return NULL
	[ ] string sReturn =  LeftOf(sIncome, ")")
	[ ] sReturn = RightOf (sReturn, "(")
	[ ] return sReturn
	[ ] 
[ ] 
[+] boolean IsIn(int iTest,string sIncome NULL)   //sIncome is in format 2-5 or NULL
	[-] if sIncome==NULL
		[-] if iTest==0
			[ ] return true
		[-] else
			[ ] return false
	[-] if !sContains(sIncome, "-")
		[ ] return false
	[ ] list of string lsStartEnd = Parse(sIncome, "-")
	[ ] int iStart=Val(lsStartEnd[1])
	[ ] int iEnd=Val(lsStartEnd[2])
	[-] if (iStart<=iTest)&&(iTest<=iEnd)
		[ ] return true
	[-] else
		[ ] return false
[ ] //get the smallest integer from a integer list
[+] integer GetSmall(list of integer lsInt)
	[-] if ListCount(lsInt)==0
		[ ] return NULL
	[ ] int iSmall = lsInt[1]
	[ ] int iEle 
	[-] for each iEle in lsInt
		[-] if iSmall>iEle
			[ ] iSmall=iEle
	[ ] return iSmall
[ ] //get the second smallest integer from a integer list
[+] integer GetSecSmall(list of integer lsInt)
	[-] if ListCount(lsInt)==0
		[ ] return NULL
	[-] if ListCount(lsInt)==1
		[ ] return lsInt[1]
	[ ] int iSmall=GetSmall(lsInt)
	[ ] int iSecSmall
	[+] if iSmall==lsInt[1]
		[ ] iSecSmall=lsInt[2]
	[+] else
		[ ] iSecSmall=lsInt[1]
	[ ] int iEle
	[+] for each iEle in lsInt
		[+] if iEle!=iSmall
			[+] if iEle<iSecSmall
				[ ] iSecSmall=iEle
	[ ] return iSecSmall
[ ] 
[+] boolean IsLastOne(list of anytype lsAny, anytype any)
	[-] if ListFind(lsAny, any)==ListCount(lsAny)
		[ ] return true
	[-] else
		[ ] return false
	[ ] 
	[ ] 
[ ] 
[+] BOOLEAN rpContains (RECT superitem, int x, int y)
	[ ] BOOLEAN result = FALSE
	[-] if x >= superitem.xPos && y >= superitem.yPos && x <= (superitem.xPos + superitem.xSize) && y <= (superitem.yPos + superitem.ySize) 
		[ ] result = TRUE 
		[ ] 
	[ ] return result
[ ] 
[+] LogArgError (ERRORDATA errormsg)
	[ ] WriteError (errormsg, "Argument ERROR:")
[ ] 
[ ] // ParseWS: Parse white space
[+] LIST OF STRING ParseWS (STRING sIncoming)
	[ ] LIST OF STRING lsResult = {}
	[ ] sIncoming = Trim(sIncoming)
	[-] while StrPos(" ", sIncoming)!=0 && sIncoming!=""
		[ ] int iPos = StrPos(" ", sIncoming)
		[ ] string aEle = SubStr(sIncoming, 1, iPos -1)
		[ ] ListAppend(lsResult, aEle)
		[ ] sIncoming = Stuff(sIncoming, 1, iPos, "")
		[ ] sIncoming = Trim(sIncoming)
	[ ] ListAppend(lsResult, sIncoming) //the last one
	[ ] return lsResult
[ ] 
